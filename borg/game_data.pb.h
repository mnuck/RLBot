// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game_data.proto

#ifndef PROTOBUF_game_5fdata_2eproto__INCLUDED
#define PROTOBUF_game_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_game_5fdata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsControllerStateImpl();
void InitDefaultsControllerState();
void InitDefaultsVector3Impl();
void InitDefaultsVector3();
void InitDefaultsRotatorImpl();
void InitDefaultsRotator();
void InitDefaultsTouchImpl();
void InitDefaultsTouch();
void InitDefaultsScoreInfoImpl();
void InitDefaultsScoreInfo();
void InitDefaultsPlayerInfoImpl();
void InitDefaultsPlayerInfo();
void InitDefaultsBallInfoImpl();
void InitDefaultsBallInfo();
void InitDefaultsBoostInfoImpl();
void InitDefaultsBoostInfo();
void InitDefaultsGameInfoImpl();
void InitDefaultsGameInfo();
void InitDefaultsGameTickPacketImpl();
void InitDefaultsGameTickPacket();
inline void InitDefaults() {
  InitDefaultsControllerState();
  InitDefaultsVector3();
  InitDefaultsRotator();
  InitDefaultsTouch();
  InitDefaultsScoreInfo();
  InitDefaultsPlayerInfo();
  InitDefaultsBallInfo();
  InitDefaultsBoostInfo();
  InitDefaultsGameInfo();
  InitDefaultsGameTickPacket();
}
}  // namespace protobuf_game_5fdata_2eproto
namespace rlbot {
namespace api {
class BallInfo;
class BallInfoDefaultTypeInternal;
extern BallInfoDefaultTypeInternal _BallInfo_default_instance_;
class BoostInfo;
class BoostInfoDefaultTypeInternal;
extern BoostInfoDefaultTypeInternal _BoostInfo_default_instance_;
class ControllerState;
class ControllerStateDefaultTypeInternal;
extern ControllerStateDefaultTypeInternal _ControllerState_default_instance_;
class GameInfo;
class GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameTickPacket;
class GameTickPacketDefaultTypeInternal;
extern GameTickPacketDefaultTypeInternal _GameTickPacket_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class Rotator;
class RotatorDefaultTypeInternal;
extern RotatorDefaultTypeInternal _Rotator_default_instance_;
class ScoreInfo;
class ScoreInfoDefaultTypeInternal;
extern ScoreInfoDefaultTypeInternal _ScoreInfo_default_instance_;
class Touch;
class TouchDefaultTypeInternal;
extern TouchDefaultTypeInternal _Touch_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace api
}  // namespace rlbot
namespace rlbot {
namespace api {

// ===================================================================

class ControllerState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.ControllerState) */ {
 public:
  ControllerState();
  virtual ~ControllerState();

  ControllerState(const ControllerState& from);

  inline ControllerState& operator=(const ControllerState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControllerState(ControllerState&& from) noexcept
    : ControllerState() {
    *this = ::std::move(from);
  }

  inline ControllerState& operator=(ControllerState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerState* internal_default_instance() {
    return reinterpret_cast<const ControllerState*>(
               &_ControllerState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ControllerState* other);
  friend void swap(ControllerState& a, ControllerState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControllerState* New() const PROTOBUF_FINAL { return New(NULL); }

  ControllerState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControllerState& from);
  void MergeFrom(const ControllerState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControllerState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float throttle = 1;
  void clear_throttle();
  static const int kThrottleFieldNumber = 1;
  float throttle() const;
  void set_throttle(float value);

  // float steer = 2;
  void clear_steer();
  static const int kSteerFieldNumber = 2;
  float steer() const;
  void set_steer(float value);

  // float pitch = 3;
  void clear_pitch();
  static const int kPitchFieldNumber = 3;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 4;
  void clear_yaw();
  static const int kYawFieldNumber = 4;
  float yaw() const;
  void set_yaw(float value);

  // float roll = 5;
  void clear_roll();
  static const int kRollFieldNumber = 5;
  float roll() const;
  void set_roll(float value);

  // bool jump = 6;
  void clear_jump();
  static const int kJumpFieldNumber = 6;
  bool jump() const;
  void set_jump(bool value);

  // bool boost = 7;
  void clear_boost();
  static const int kBoostFieldNumber = 7;
  bool boost() const;
  void set_boost(bool value);

  // bool handbrake = 8;
  void clear_handbrake();
  static const int kHandbrakeFieldNumber = 8;
  bool handbrake() const;
  void set_handbrake(bool value);

  // @@protoc_insertion_point(class_scope:rlbot.api.ControllerState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float throttle_;
  float steer_;
  float pitch_;
  float yaw_;
  float roll_;
  bool jump_;
  bool boost_;
  bool handbrake_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsControllerStateImpl();
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Vector3* other);
  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Vector3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsVector3Impl();
};
// -------------------------------------------------------------------

class Rotator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.Rotator) */ {
 public:
  Rotator();
  virtual ~Rotator();

  Rotator(const Rotator& from);

  inline Rotator& operator=(const Rotator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rotator(Rotator&& from) noexcept
    : Rotator() {
    *this = ::std::move(from);
  }

  inline Rotator& operator=(Rotator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rotator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rotator* internal_default_instance() {
    return reinterpret_cast<const Rotator*>(
               &_Rotator_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Rotator* other);
  friend void swap(Rotator& a, Rotator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rotator* New() const PROTOBUF_FINAL { return New(NULL); }

  Rotator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rotator& from);
  void MergeFrom(const Rotator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rotator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float pitch = 1;
  void clear_pitch();
  static const int kPitchFieldNumber = 1;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // float roll = 3;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Rotator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float pitch_;
  float yaw_;
  float roll_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsRotatorImpl();
};
// -------------------------------------------------------------------

class Touch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.Touch) */ {
 public:
  Touch();
  virtual ~Touch();

  Touch(const Touch& from);

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Touch(Touch&& from) noexcept
    : Touch() {
    *this = ::std::move(from);
  }

  inline Touch& operator=(Touch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Touch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Touch* internal_default_instance() {
    return reinterpret_cast<const Touch*>(
               &_Touch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Touch* other);
  friend void swap(Touch& a, Touch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Touch* New() const PROTOBUF_FINAL { return New(NULL); }

  Touch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Touch& from);
  void MergeFrom(const Touch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Touch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string player_name = 1;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 1;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  #if LANG_CXX11
  void set_player_name(::std::string&& value);
  #endif
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // .rlbot.api.Vector3 location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* release_location();
  ::rlbot::api::Vector3* mutable_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // .rlbot.api.Vector3 normal = 4;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 4;
  const ::rlbot::api::Vector3& normal() const;
  ::rlbot::api::Vector3* release_normal();
  ::rlbot::api::Vector3* mutable_normal();
  void set_allocated_normal(::rlbot::api::Vector3* normal);

  // float game_seconds = 2;
  void clear_game_seconds();
  static const int kGameSecondsFieldNumber = 2;
  float game_seconds() const;
  void set_game_seconds(float value);

  // @@protoc_insertion_point(class_scope:rlbot.api.Touch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Vector3* normal_;
  float game_seconds_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsTouchImpl();
};
// -------------------------------------------------------------------

class ScoreInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.ScoreInfo) */ {
 public:
  ScoreInfo();
  virtual ~ScoreInfo();

  ScoreInfo(const ScoreInfo& from);

  inline ScoreInfo& operator=(const ScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScoreInfo(ScoreInfo&& from) noexcept
    : ScoreInfo() {
    *this = ::std::move(from);
  }

  inline ScoreInfo& operator=(ScoreInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoreInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScoreInfo* internal_default_instance() {
    return reinterpret_cast<const ScoreInfo*>(
               &_ScoreInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ScoreInfo* other);
  friend void swap(ScoreInfo& a, ScoreInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScoreInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ScoreInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScoreInfo& from);
  void MergeFrom(const ScoreInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScoreInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 score = 1;
  void clear_score();
  static const int kScoreFieldNumber = 1;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // int32 goals = 2;
  void clear_goals();
  static const int kGoalsFieldNumber = 2;
  ::google::protobuf::int32 goals() const;
  void set_goals(::google::protobuf::int32 value);

  // int32 own_goals = 3;
  void clear_own_goals();
  static const int kOwnGoalsFieldNumber = 3;
  ::google::protobuf::int32 own_goals() const;
  void set_own_goals(::google::protobuf::int32 value);

  // int32 assists = 4;
  void clear_assists();
  static const int kAssistsFieldNumber = 4;
  ::google::protobuf::int32 assists() const;
  void set_assists(::google::protobuf::int32 value);

  // int32 saves = 5;
  void clear_saves();
  static const int kSavesFieldNumber = 5;
  ::google::protobuf::int32 saves() const;
  void set_saves(::google::protobuf::int32 value);

  // int32 shots = 6;
  void clear_shots();
  static const int kShotsFieldNumber = 6;
  ::google::protobuf::int32 shots() const;
  void set_shots(::google::protobuf::int32 value);

  // int32 demolitions = 7;
  void clear_demolitions();
  static const int kDemolitionsFieldNumber = 7;
  ::google::protobuf::int32 demolitions() const;
  void set_demolitions(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.ScoreInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 goals_;
  ::google::protobuf::int32 own_goals_;
  ::google::protobuf::int32 assists_;
  ::google::protobuf::int32 saves_;
  ::google::protobuf::int32 shots_;
  ::google::protobuf::int32 demolitions_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsScoreInfoImpl();
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PlayerInfo* other);
  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 12;
  void clear_name();
  static const int kNameFieldNumber = 12;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .rlbot.api.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* release_location();
  ::rlbot::api::Vector3* mutable_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // .rlbot.api.Rotator rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::rlbot::api::Rotator& rotation() const;
  ::rlbot::api::Rotator* release_rotation();
  ::rlbot::api::Rotator* mutable_rotation();
  void set_allocated_rotation(::rlbot::api::Rotator* rotation);

  // .rlbot.api.Vector3 velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  const ::rlbot::api::Vector3& velocity() const;
  ::rlbot::api::Vector3* release_velocity();
  ::rlbot::api::Vector3* mutable_velocity();
  void set_allocated_velocity(::rlbot::api::Vector3* velocity);

  // .rlbot.api.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  const ::rlbot::api::Vector3& angular_velocity() const;
  ::rlbot::api::Vector3* release_angular_velocity();
  ::rlbot::api::Vector3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity);

  // .rlbot.api.ScoreInfo score_info = 5;
  bool has_score_info() const;
  void clear_score_info();
  static const int kScoreInfoFieldNumber = 5;
  const ::rlbot::api::ScoreInfo& score_info() const;
  ::rlbot::api::ScoreInfo* release_score_info();
  ::rlbot::api::ScoreInfo* mutable_score_info();
  void set_allocated_score_info(::rlbot::api::ScoreInfo* score_info);

  // bool is_demolished = 6;
  void clear_is_demolished();
  static const int kIsDemolishedFieldNumber = 6;
  bool is_demolished() const;
  void set_is_demolished(bool value);

  // bool is_midair = 7;
  void clear_is_midair();
  static const int kIsMidairFieldNumber = 7;
  bool is_midair() const;
  void set_is_midair(bool value);

  // bool is_supersonic = 8;
  void clear_is_supersonic();
  static const int kIsSupersonicFieldNumber = 8;
  bool is_supersonic() const;
  void set_is_supersonic(bool value);

  // bool is_bot = 9;
  void clear_is_bot();
  static const int kIsBotFieldNumber = 9;
  bool is_bot() const;
  void set_is_bot(bool value);

  // bool jumped = 10;
  void clear_jumped();
  static const int kJumpedFieldNumber = 10;
  bool jumped() const;
  void set_jumped(bool value);

  // bool double_jumped = 11;
  void clear_double_jumped();
  static const int kDoubleJumpedFieldNumber = 11;
  bool double_jumped() const;
  void set_double_jumped(bool value);

  // int32 team = 13;
  void clear_team();
  static const int kTeamFieldNumber = 13;
  ::google::protobuf::int32 team() const;
  void set_team(::google::protobuf::int32 value);

  // int32 boost = 14;
  void clear_boost();
  static const int kBoostFieldNumber = 14;
  ::google::protobuf::int32 boost() const;
  void set_boost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.PlayerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Rotator* rotation_;
  ::rlbot::api::Vector3* velocity_;
  ::rlbot::api::Vector3* angular_velocity_;
  ::rlbot::api::ScoreInfo* score_info_;
  bool is_demolished_;
  bool is_midair_;
  bool is_supersonic_;
  bool is_bot_;
  bool jumped_;
  bool double_jumped_;
  ::google::protobuf::int32 team_;
  ::google::protobuf::int32 boost_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsPlayerInfoImpl();
};
// -------------------------------------------------------------------

class BallInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.BallInfo) */ {
 public:
  BallInfo();
  virtual ~BallInfo();

  BallInfo(const BallInfo& from);

  inline BallInfo& operator=(const BallInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallInfo(BallInfo&& from) noexcept
    : BallInfo() {
    *this = ::std::move(from);
  }

  inline BallInfo& operator=(BallInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BallInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BallInfo* internal_default_instance() {
    return reinterpret_cast<const BallInfo*>(
               &_BallInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(BallInfo* other);
  friend void swap(BallInfo& a, BallInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BallInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BallInfo& from);
  void MergeFrom(const BallInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BallInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rlbot.api.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* release_location();
  ::rlbot::api::Vector3* mutable_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // .rlbot.api.Rotator rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::rlbot::api::Rotator& rotation() const;
  ::rlbot::api::Rotator* release_rotation();
  ::rlbot::api::Rotator* mutable_rotation();
  void set_allocated_rotation(::rlbot::api::Rotator* rotation);

  // .rlbot.api.Vector3 velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  const ::rlbot::api::Vector3& velocity() const;
  ::rlbot::api::Vector3* release_velocity();
  ::rlbot::api::Vector3* mutable_velocity();
  void set_allocated_velocity(::rlbot::api::Vector3* velocity);

  // .rlbot.api.Vector3 angular_velocity = 4;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 4;
  const ::rlbot::api::Vector3& angular_velocity() const;
  ::rlbot::api::Vector3* release_angular_velocity();
  ::rlbot::api::Vector3* mutable_angular_velocity();
  void set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity);

  // .rlbot.api.Vector3 acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  const ::rlbot::api::Vector3& acceleration() const;
  ::rlbot::api::Vector3* release_acceleration();
  ::rlbot::api::Vector3* mutable_acceleration();
  void set_allocated_acceleration(::rlbot::api::Vector3* acceleration);

  // .rlbot.api.Touch latest_touch = 6;
  bool has_latest_touch() const;
  void clear_latest_touch();
  static const int kLatestTouchFieldNumber = 6;
  const ::rlbot::api::Touch& latest_touch() const;
  ::rlbot::api::Touch* release_latest_touch();
  ::rlbot::api::Touch* mutable_latest_touch();
  void set_allocated_latest_touch(::rlbot::api::Touch* latest_touch);

  // @@protoc_insertion_point(class_scope:rlbot.api.BallInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rlbot::api::Vector3* location_;
  ::rlbot::api::Rotator* rotation_;
  ::rlbot::api::Vector3* velocity_;
  ::rlbot::api::Vector3* angular_velocity_;
  ::rlbot::api::Vector3* acceleration_;
  ::rlbot::api::Touch* latest_touch_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsBallInfoImpl();
};
// -------------------------------------------------------------------

class BoostInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.BoostInfo) */ {
 public:
  BoostInfo();
  virtual ~BoostInfo();

  BoostInfo(const BoostInfo& from);

  inline BoostInfo& operator=(const BoostInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoostInfo(BoostInfo&& from) noexcept
    : BoostInfo() {
    *this = ::std::move(from);
  }

  inline BoostInfo& operator=(BoostInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoostInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoostInfo* internal_default_instance() {
    return reinterpret_cast<const BoostInfo*>(
               &_BoostInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BoostInfo* other);
  friend void swap(BoostInfo& a, BoostInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoostInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BoostInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoostInfo& from);
  void MergeFrom(const BoostInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoostInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .rlbot.api.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::rlbot::api::Vector3& location() const;
  ::rlbot::api::Vector3* release_location();
  ::rlbot::api::Vector3* mutable_location();
  void set_allocated_location(::rlbot::api::Vector3* location);

  // bool is_active = 2;
  void clear_is_active();
  static const int kIsActiveFieldNumber = 2;
  bool is_active() const;
  void set_is_active(bool value);

  // int32 timer = 3;
  void clear_timer();
  static const int kTimerFieldNumber = 3;
  ::google::protobuf::int32 timer() const;
  void set_timer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.BoostInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::rlbot::api::Vector3* location_;
  bool is_active_;
  ::google::protobuf::int32 timer_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsBoostInfoImpl();
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GameInfo* other);
  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  GameInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float seconds_elapsed = 1;
  void clear_seconds_elapsed();
  static const int kSecondsElapsedFieldNumber = 1;
  float seconds_elapsed() const;
  void set_seconds_elapsed(float value);

  // float game_time_remaining = 2;
  void clear_game_time_remaining();
  static const int kGameTimeRemainingFieldNumber = 2;
  float game_time_remaining() const;
  void set_game_time_remaining(float value);

  // bool is_overtime = 3;
  void clear_is_overtime();
  static const int kIsOvertimeFieldNumber = 3;
  bool is_overtime() const;
  void set_is_overtime(bool value);

  // bool is_unlimited_time = 4;
  void clear_is_unlimited_time();
  static const int kIsUnlimitedTimeFieldNumber = 4;
  bool is_unlimited_time() const;
  void set_is_unlimited_time(bool value);

  // bool is_round_active = 5;
  void clear_is_round_active();
  static const int kIsRoundActiveFieldNumber = 5;
  bool is_round_active() const;
  void set_is_round_active(bool value);

  // bool is_kickoff_pause = 6;
  void clear_is_kickoff_pause();
  static const int kIsKickoffPauseFieldNumber = 6;
  bool is_kickoff_pause() const;
  void set_is_kickoff_pause(bool value);

  // bool is_match_ended = 7;
  void clear_is_match_ended();
  static const int kIsMatchEndedFieldNumber = 7;
  bool is_match_ended() const;
  void set_is_match_ended(bool value);

  // @@protoc_insertion_point(class_scope:rlbot.api.GameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float seconds_elapsed_;
  float game_time_remaining_;
  bool is_overtime_;
  bool is_unlimited_time_;
  bool is_round_active_;
  bool is_kickoff_pause_;
  bool is_match_ended_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsGameInfoImpl();
};
// -------------------------------------------------------------------

class GameTickPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rlbot.api.GameTickPacket) */ {
 public:
  GameTickPacket();
  virtual ~GameTickPacket();

  GameTickPacket(const GameTickPacket& from);

  inline GameTickPacket& operator=(const GameTickPacket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameTickPacket(GameTickPacket&& from) noexcept
    : GameTickPacket() {
    *this = ::std::move(from);
  }

  inline GameTickPacket& operator=(GameTickPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTickPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameTickPacket* internal_default_instance() {
    return reinterpret_cast<const GameTickPacket*>(
               &_GameTickPacket_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(GameTickPacket* other);
  friend void swap(GameTickPacket& a, GameTickPacket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameTickPacket* New() const PROTOBUF_FINAL { return New(NULL); }

  GameTickPacket* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameTickPacket& from);
  void MergeFrom(const GameTickPacket& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameTickPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rlbot.api.PlayerInfo players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::rlbot::api::PlayerInfo& players(int index) const;
  ::rlbot::api::PlayerInfo* mutable_players(int index);
  ::rlbot::api::PlayerInfo* add_players();
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >&
      players() const;

  // repeated .rlbot.api.BoostInfo boost_pads = 3;
  int boost_pads_size() const;
  void clear_boost_pads();
  static const int kBoostPadsFieldNumber = 3;
  const ::rlbot::api::BoostInfo& boost_pads(int index) const;
  ::rlbot::api::BoostInfo* mutable_boost_pads(int index);
  ::rlbot::api::BoostInfo* add_boost_pads();
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >*
      mutable_boost_pads();
  const ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >&
      boost_pads() const;

  // .rlbot.api.BallInfo ball = 4;
  bool has_ball() const;
  void clear_ball();
  static const int kBallFieldNumber = 4;
  const ::rlbot::api::BallInfo& ball() const;
  ::rlbot::api::BallInfo* release_ball();
  ::rlbot::api::BallInfo* mutable_ball();
  void set_allocated_ball(::rlbot::api::BallInfo* ball);

  // .rlbot.api.GameInfo game_info = 5;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 5;
  const ::rlbot::api::GameInfo& game_info() const;
  ::rlbot::api::GameInfo* release_game_info();
  ::rlbot::api::GameInfo* mutable_game_info();
  void set_allocated_game_info(::rlbot::api::GameInfo* game_info);

  // int32 player_index = 2;
  void clear_player_index();
  static const int kPlayerIndexFieldNumber = 2;
  ::google::protobuf::int32 player_index() const;
  void set_player_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rlbot.api.GameTickPacket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo > players_;
  ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo > boost_pads_;
  ::rlbot::api::BallInfo* ball_;
  ::rlbot::api::GameInfo* game_info_;
  ::google::protobuf::int32 player_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_5fdata_2eproto::TableStruct;
  friend void ::protobuf_game_5fdata_2eproto::InitDefaultsGameTickPacketImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ControllerState

// float throttle = 1;
inline void ControllerState::clear_throttle() {
  throttle_ = 0;
}
inline float ControllerState::throttle() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.throttle)
  return throttle_;
}
inline void ControllerState::set_throttle(float value) {
  
  throttle_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.throttle)
}

// float steer = 2;
inline void ControllerState::clear_steer() {
  steer_ = 0;
}
inline float ControllerState::steer() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.steer)
  return steer_;
}
inline void ControllerState::set_steer(float value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.steer)
}

// float pitch = 3;
inline void ControllerState::clear_pitch() {
  pitch_ = 0;
}
inline float ControllerState::pitch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.pitch)
  return pitch_;
}
inline void ControllerState::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.pitch)
}

// float yaw = 4;
inline void ControllerState::clear_yaw() {
  yaw_ = 0;
}
inline float ControllerState::yaw() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.yaw)
  return yaw_;
}
inline void ControllerState::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.yaw)
}

// float roll = 5;
inline void ControllerState::clear_roll() {
  roll_ = 0;
}
inline float ControllerState::roll() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.roll)
  return roll_;
}
inline void ControllerState::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.roll)
}

// bool jump = 6;
inline void ControllerState::clear_jump() {
  jump_ = false;
}
inline bool ControllerState::jump() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.jump)
  return jump_;
}
inline void ControllerState::set_jump(bool value) {
  
  jump_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.jump)
}

// bool boost = 7;
inline void ControllerState::clear_boost() {
  boost_ = false;
}
inline bool ControllerState::boost() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.boost)
  return boost_;
}
inline void ControllerState::set_boost(bool value) {
  
  boost_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.boost)
}

// bool handbrake = 8;
inline void ControllerState::clear_handbrake() {
  handbrake_ = false;
}
inline bool ControllerState::handbrake() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ControllerState.handbrake)
  return handbrake_;
}
inline void ControllerState::set_handbrake(bool value) {
  
  handbrake_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ControllerState.handbrake)
}

// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Vector3.z)
}

// -------------------------------------------------------------------

// Rotator

// float pitch = 1;
inline void Rotator::clear_pitch() {
  pitch_ = 0;
}
inline float Rotator::pitch() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.pitch)
  return pitch_;
}
inline void Rotator::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.pitch)
}

// float yaw = 2;
inline void Rotator::clear_yaw() {
  yaw_ = 0;
}
inline float Rotator::yaw() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.yaw)
  return yaw_;
}
inline void Rotator::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.yaw)
}

// float roll = 3;
inline void Rotator::clear_roll() {
  roll_ = 0;
}
inline float Rotator::roll() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Rotator.roll)
  return roll_;
}
inline void Rotator::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Rotator.roll)
}

// -------------------------------------------------------------------

// Touch

// string player_name = 1;
inline void Touch::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Touch::player_name() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.player_name)
  return player_name_.GetNoArena();
}
inline void Touch::set_player_name(const ::std::string& value) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rlbot.api.Touch.player_name)
}
#if LANG_CXX11
inline void Touch::set_player_name(::std::string&& value) {
  
  player_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rlbot.api.Touch.player_name)
}
#endif
inline void Touch::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rlbot.api.Touch.player_name)
}
inline void Touch::set_player_name(const char* value, size_t size) {
  
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rlbot.api.Touch.player_name)
}
inline ::std::string* Touch::mutable_player_name() {
  
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Touch::release_player_name() {
  // @@protoc_insertion_point(field_release:rlbot.api.Touch.player_name)
  
  return player_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Touch::set_allocated_player_name(::std::string* player_name) {
  if (player_name != NULL) {
    
  } else {
    
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.player_name)
}

// float game_seconds = 2;
inline void Touch::clear_game_seconds() {
  game_seconds_ = 0;
}
inline float Touch::game_seconds() const {
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.game_seconds)
  return game_seconds_;
}
inline void Touch::set_game_seconds(float value) {
  
  game_seconds_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.Touch.game_seconds)
}

// .rlbot.api.Vector3 location = 3;
inline bool Touch::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Touch::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& Touch::location() const {
  const ::rlbot::api::Vector3* p = location_;
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.location)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* Touch::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.Touch.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* Touch::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.location)
  return location_;
}
inline void Touch::set_allocated_location(::rlbot::api::Vector3* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.location)
}

// .rlbot.api.Vector3 normal = 4;
inline bool Touch::has_normal() const {
  return this != internal_default_instance() && normal_ != NULL;
}
inline void Touch::clear_normal() {
  if (GetArenaNoVirtual() == NULL && normal_ != NULL) {
    delete normal_;
  }
  normal_ = NULL;
}
inline const ::rlbot::api::Vector3& Touch::normal() const {
  const ::rlbot::api::Vector3* p = normal_;
  // @@protoc_insertion_point(field_get:rlbot.api.Touch.normal)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* Touch::release_normal() {
  // @@protoc_insertion_point(field_release:rlbot.api.Touch.normal)
  
  ::rlbot::api::Vector3* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* Touch::mutable_normal() {
  
  if (normal_ == NULL) {
    normal_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.Touch.normal)
  return normal_;
}
inline void Touch::set_allocated_normal(::rlbot::api::Vector3* normal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete normal_;
  }
  if (normal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      normal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    
  } else {
    
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.Touch.normal)
}

// -------------------------------------------------------------------

// ScoreInfo

// int32 score = 1;
inline void ScoreInfo::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::score() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.score)
  return score_;
}
inline void ScoreInfo::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.score)
}

// int32 goals = 2;
inline void ScoreInfo::clear_goals() {
  goals_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::goals() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.goals)
  return goals_;
}
inline void ScoreInfo::set_goals(::google::protobuf::int32 value) {
  
  goals_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.goals)
}

// int32 own_goals = 3;
inline void ScoreInfo::clear_own_goals() {
  own_goals_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::own_goals() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.own_goals)
  return own_goals_;
}
inline void ScoreInfo::set_own_goals(::google::protobuf::int32 value) {
  
  own_goals_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.own_goals)
}

// int32 assists = 4;
inline void ScoreInfo::clear_assists() {
  assists_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::assists() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.assists)
  return assists_;
}
inline void ScoreInfo::set_assists(::google::protobuf::int32 value) {
  
  assists_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.assists)
}

// int32 saves = 5;
inline void ScoreInfo::clear_saves() {
  saves_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::saves() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.saves)
  return saves_;
}
inline void ScoreInfo::set_saves(::google::protobuf::int32 value) {
  
  saves_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.saves)
}

// int32 shots = 6;
inline void ScoreInfo::clear_shots() {
  shots_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::shots() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.shots)
  return shots_;
}
inline void ScoreInfo::set_shots(::google::protobuf::int32 value) {
  
  shots_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.shots)
}

// int32 demolitions = 7;
inline void ScoreInfo::clear_demolitions() {
  demolitions_ = 0;
}
inline ::google::protobuf::int32 ScoreInfo::demolitions() const {
  // @@protoc_insertion_point(field_get:rlbot.api.ScoreInfo.demolitions)
  return demolitions_;
}
inline void ScoreInfo::set_demolitions(::google::protobuf::int32 value) {
  
  demolitions_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.ScoreInfo.demolitions)
}

// -------------------------------------------------------------------

// PlayerInfo

// .rlbot.api.Vector3 location = 1;
inline bool PlayerInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void PlayerInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& PlayerInfo::location() const {
  const ::rlbot::api::Vector3* p = location_;
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.location)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* PlayerInfo::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.location)
  return location_;
}
inline void PlayerInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.location)
}

// .rlbot.api.Rotator rotation = 2;
inline bool PlayerInfo::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void PlayerInfo::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) {
    delete rotation_;
  }
  rotation_ = NULL;
}
inline const ::rlbot::api::Rotator& PlayerInfo::rotation() const {
  const ::rlbot::api::Rotator* p = rotation_;
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Rotator*>(
      &::rlbot::api::_Rotator_default_instance_);
}
inline ::rlbot::api::Rotator* PlayerInfo::release_rotation() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.rotation)
  
  ::rlbot::api::Rotator* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::rlbot::api::Rotator* PlayerInfo::mutable_rotation() {
  
  if (rotation_ == NULL) {
    rotation_ = new ::rlbot::api::Rotator;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.rotation)
  return rotation_;
}
inline void PlayerInfo::set_allocated_rotation(::rlbot::api::Rotator* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.rotation)
}

// .rlbot.api.Vector3 velocity = 3;
inline bool PlayerInfo::has_velocity() const {
  return this != internal_default_instance() && velocity_ != NULL;
}
inline void PlayerInfo::clear_velocity() {
  if (GetArenaNoVirtual() == NULL && velocity_ != NULL) {
    delete velocity_;
  }
  velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& PlayerInfo::velocity() const {
  const ::rlbot::api::Vector3* p = velocity_;
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* PlayerInfo::release_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.velocity)
  
  ::rlbot::api::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.velocity)
  return velocity_;
}
inline void PlayerInfo::set_allocated_velocity(::rlbot::api::Vector3* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.velocity)
}

// .rlbot.api.Vector3 angular_velocity = 4;
inline bool PlayerInfo::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline void PlayerInfo::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) {
    delete angular_velocity_;
  }
  angular_velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& PlayerInfo::angular_velocity() const {
  const ::rlbot::api::Vector3* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* PlayerInfo::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.angular_velocity)
  
  ::rlbot::api::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* PlayerInfo::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.angular_velocity)
  return angular_velocity_;
}
inline void PlayerInfo::set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.angular_velocity)
}

// .rlbot.api.ScoreInfo score_info = 5;
inline bool PlayerInfo::has_score_info() const {
  return this != internal_default_instance() && score_info_ != NULL;
}
inline void PlayerInfo::clear_score_info() {
  if (GetArenaNoVirtual() == NULL && score_info_ != NULL) {
    delete score_info_;
  }
  score_info_ = NULL;
}
inline const ::rlbot::api::ScoreInfo& PlayerInfo::score_info() const {
  const ::rlbot::api::ScoreInfo* p = score_info_;
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.score_info)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::ScoreInfo*>(
      &::rlbot::api::_ScoreInfo_default_instance_);
}
inline ::rlbot::api::ScoreInfo* PlayerInfo::release_score_info() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.score_info)
  
  ::rlbot::api::ScoreInfo* temp = score_info_;
  score_info_ = NULL;
  return temp;
}
inline ::rlbot::api::ScoreInfo* PlayerInfo::mutable_score_info() {
  
  if (score_info_ == NULL) {
    score_info_ = new ::rlbot::api::ScoreInfo;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.score_info)
  return score_info_;
}
inline void PlayerInfo::set_allocated_score_info(::rlbot::api::ScoreInfo* score_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete score_info_;
  }
  if (score_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      score_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, score_info, submessage_arena);
    }
    
  } else {
    
  }
  score_info_ = score_info;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.score_info)
}

// bool is_demolished = 6;
inline void PlayerInfo::clear_is_demolished() {
  is_demolished_ = false;
}
inline bool PlayerInfo::is_demolished() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_demolished)
  return is_demolished_;
}
inline void PlayerInfo::set_is_demolished(bool value) {
  
  is_demolished_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_demolished)
}

// bool is_midair = 7;
inline void PlayerInfo::clear_is_midair() {
  is_midair_ = false;
}
inline bool PlayerInfo::is_midair() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_midair)
  return is_midair_;
}
inline void PlayerInfo::set_is_midair(bool value) {
  
  is_midair_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_midair)
}

// bool is_supersonic = 8;
inline void PlayerInfo::clear_is_supersonic() {
  is_supersonic_ = false;
}
inline bool PlayerInfo::is_supersonic() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_supersonic)
  return is_supersonic_;
}
inline void PlayerInfo::set_is_supersonic(bool value) {
  
  is_supersonic_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_supersonic)
}

// bool is_bot = 9;
inline void PlayerInfo::clear_is_bot() {
  is_bot_ = false;
}
inline bool PlayerInfo::is_bot() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.is_bot)
  return is_bot_;
}
inline void PlayerInfo::set_is_bot(bool value) {
  
  is_bot_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.is_bot)
}

// bool jumped = 10;
inline void PlayerInfo::clear_jumped() {
  jumped_ = false;
}
inline bool PlayerInfo::jumped() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.jumped)
  return jumped_;
}
inline void PlayerInfo::set_jumped(bool value) {
  
  jumped_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.jumped)
}

// bool double_jumped = 11;
inline void PlayerInfo::clear_double_jumped() {
  double_jumped_ = false;
}
inline bool PlayerInfo::double_jumped() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.double_jumped)
  return double_jumped_;
}
inline void PlayerInfo::set_double_jumped(bool value) {
  
  double_jumped_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.double_jumped)
}

// string name = 12;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.name)
  return name_.GetNoArena();
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.name)
}
#if LANG_CXX11
inline void PlayerInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rlbot.api.PlayerInfo.name)
}
#endif
inline void PlayerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rlbot.api.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rlbot.api.PlayerInfo.name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:rlbot.api.PlayerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:rlbot.api.PlayerInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.PlayerInfo.name)
}

// int32 team = 13;
inline void PlayerInfo::clear_team() {
  team_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::team() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.team)
  return team_;
}
inline void PlayerInfo::set_team(::google::protobuf::int32 value) {
  
  team_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.team)
}

// int32 boost = 14;
inline void PlayerInfo::clear_boost() {
  boost_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::boost() const {
  // @@protoc_insertion_point(field_get:rlbot.api.PlayerInfo.boost)
  return boost_;
}
inline void PlayerInfo::set_boost(::google::protobuf::int32 value) {
  
  boost_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.PlayerInfo.boost)
}

// -------------------------------------------------------------------

// BallInfo

// .rlbot.api.Vector3 location = 1;
inline bool BallInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void BallInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::location() const {
  const ::rlbot::api::Vector3* p = location_;
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.location)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* BallInfo::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.location)
  return location_;
}
inline void BallInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.location)
}

// .rlbot.api.Rotator rotation = 2;
inline bool BallInfo::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void BallInfo::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) {
    delete rotation_;
  }
  rotation_ = NULL;
}
inline const ::rlbot::api::Rotator& BallInfo::rotation() const {
  const ::rlbot::api::Rotator* p = rotation_;
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Rotator*>(
      &::rlbot::api::_Rotator_default_instance_);
}
inline ::rlbot::api::Rotator* BallInfo::release_rotation() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.rotation)
  
  ::rlbot::api::Rotator* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline ::rlbot::api::Rotator* BallInfo::mutable_rotation() {
  
  if (rotation_ == NULL) {
    rotation_ = new ::rlbot::api::Rotator;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.rotation)
  return rotation_;
}
inline void BallInfo::set_allocated_rotation(::rlbot::api::Rotator* rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rotation_;
  }
  if (rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.rotation)
}

// .rlbot.api.Vector3 velocity = 3;
inline bool BallInfo::has_velocity() const {
  return this != internal_default_instance() && velocity_ != NULL;
}
inline void BallInfo::clear_velocity() {
  if (GetArenaNoVirtual() == NULL && velocity_ != NULL) {
    delete velocity_;
  }
  velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::velocity() const {
  const ::rlbot::api::Vector3* p = velocity_;
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* BallInfo::release_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.velocity)
  
  ::rlbot::api::Vector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.velocity)
  return velocity_;
}
inline void BallInfo::set_allocated_velocity(::rlbot::api::Vector3* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.velocity)
}

// .rlbot.api.Vector3 angular_velocity = 4;
inline bool BallInfo::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline void BallInfo::clear_angular_velocity() {
  if (GetArenaNoVirtual() == NULL && angular_velocity_ != NULL) {
    delete angular_velocity_;
  }
  angular_velocity_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::angular_velocity() const {
  const ::rlbot::api::Vector3* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* BallInfo::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.angular_velocity)
  
  ::rlbot::api::Vector3* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.angular_velocity)
  return angular_velocity_;
}
inline void BallInfo::set_allocated_angular_velocity(::rlbot::api::Vector3* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.angular_velocity)
}

// .rlbot.api.Vector3 acceleration = 5;
inline bool BallInfo::has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != NULL;
}
inline void BallInfo::clear_acceleration() {
  if (GetArenaNoVirtual() == NULL && acceleration_ != NULL) {
    delete acceleration_;
  }
  acceleration_ = NULL;
}
inline const ::rlbot::api::Vector3& BallInfo::acceleration() const {
  const ::rlbot::api::Vector3* p = acceleration_;
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* BallInfo::release_acceleration() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.acceleration)
  
  ::rlbot::api::Vector3* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* BallInfo::mutable_acceleration() {
  
  if (acceleration_ == NULL) {
    acceleration_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.acceleration)
  return acceleration_;
}
inline void BallInfo::set_allocated_acceleration(::rlbot::api::Vector3* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acceleration_;
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.acceleration)
}

// .rlbot.api.Touch latest_touch = 6;
inline bool BallInfo::has_latest_touch() const {
  return this != internal_default_instance() && latest_touch_ != NULL;
}
inline void BallInfo::clear_latest_touch() {
  if (GetArenaNoVirtual() == NULL && latest_touch_ != NULL) {
    delete latest_touch_;
  }
  latest_touch_ = NULL;
}
inline const ::rlbot::api::Touch& BallInfo::latest_touch() const {
  const ::rlbot::api::Touch* p = latest_touch_;
  // @@protoc_insertion_point(field_get:rlbot.api.BallInfo.latest_touch)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Touch*>(
      &::rlbot::api::_Touch_default_instance_);
}
inline ::rlbot::api::Touch* BallInfo::release_latest_touch() {
  // @@protoc_insertion_point(field_release:rlbot.api.BallInfo.latest_touch)
  
  ::rlbot::api::Touch* temp = latest_touch_;
  latest_touch_ = NULL;
  return temp;
}
inline ::rlbot::api::Touch* BallInfo::mutable_latest_touch() {
  
  if (latest_touch_ == NULL) {
    latest_touch_ = new ::rlbot::api::Touch;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BallInfo.latest_touch)
  return latest_touch_;
}
inline void BallInfo::set_allocated_latest_touch(::rlbot::api::Touch* latest_touch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete latest_touch_;
  }
  if (latest_touch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      latest_touch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, latest_touch, submessage_arena);
    }
    
  } else {
    
  }
  latest_touch_ = latest_touch;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BallInfo.latest_touch)
}

// -------------------------------------------------------------------

// BoostInfo

// .rlbot.api.Vector3 location = 1;
inline bool BoostInfo::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void BoostInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::rlbot::api::Vector3& BoostInfo::location() const {
  const ::rlbot::api::Vector3* p = location_;
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.location)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::Vector3*>(
      &::rlbot::api::_Vector3_default_instance_);
}
inline ::rlbot::api::Vector3* BoostInfo::release_location() {
  // @@protoc_insertion_point(field_release:rlbot.api.BoostInfo.location)
  
  ::rlbot::api::Vector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::rlbot::api::Vector3* BoostInfo::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::rlbot::api::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.BoostInfo.location)
  return location_;
}
inline void BoostInfo::set_allocated_location(::rlbot::api::Vector3* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.BoostInfo.location)
}

// bool is_active = 2;
inline void BoostInfo::clear_is_active() {
  is_active_ = false;
}
inline bool BoostInfo::is_active() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.is_active)
  return is_active_;
}
inline void BoostInfo::set_is_active(bool value) {
  
  is_active_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.BoostInfo.is_active)
}

// int32 timer = 3;
inline void BoostInfo::clear_timer() {
  timer_ = 0;
}
inline ::google::protobuf::int32 BoostInfo::timer() const {
  // @@protoc_insertion_point(field_get:rlbot.api.BoostInfo.timer)
  return timer_;
}
inline void BoostInfo::set_timer(::google::protobuf::int32 value) {
  
  timer_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.BoostInfo.timer)
}

// -------------------------------------------------------------------

// GameInfo

// float seconds_elapsed = 1;
inline void GameInfo::clear_seconds_elapsed() {
  seconds_elapsed_ = 0;
}
inline float GameInfo::seconds_elapsed() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.seconds_elapsed)
  return seconds_elapsed_;
}
inline void GameInfo::set_seconds_elapsed(float value) {
  
  seconds_elapsed_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.seconds_elapsed)
}

// float game_time_remaining = 2;
inline void GameInfo::clear_game_time_remaining() {
  game_time_remaining_ = 0;
}
inline float GameInfo::game_time_remaining() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.game_time_remaining)
  return game_time_remaining_;
}
inline void GameInfo::set_game_time_remaining(float value) {
  
  game_time_remaining_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.game_time_remaining)
}

// bool is_overtime = 3;
inline void GameInfo::clear_is_overtime() {
  is_overtime_ = false;
}
inline bool GameInfo::is_overtime() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_overtime)
  return is_overtime_;
}
inline void GameInfo::set_is_overtime(bool value) {
  
  is_overtime_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_overtime)
}

// bool is_unlimited_time = 4;
inline void GameInfo::clear_is_unlimited_time() {
  is_unlimited_time_ = false;
}
inline bool GameInfo::is_unlimited_time() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_unlimited_time)
  return is_unlimited_time_;
}
inline void GameInfo::set_is_unlimited_time(bool value) {
  
  is_unlimited_time_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_unlimited_time)
}

// bool is_round_active = 5;
inline void GameInfo::clear_is_round_active() {
  is_round_active_ = false;
}
inline bool GameInfo::is_round_active() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_round_active)
  return is_round_active_;
}
inline void GameInfo::set_is_round_active(bool value) {
  
  is_round_active_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_round_active)
}

// bool is_kickoff_pause = 6;
inline void GameInfo::clear_is_kickoff_pause() {
  is_kickoff_pause_ = false;
}
inline bool GameInfo::is_kickoff_pause() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_kickoff_pause)
  return is_kickoff_pause_;
}
inline void GameInfo::set_is_kickoff_pause(bool value) {
  
  is_kickoff_pause_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_kickoff_pause)
}

// bool is_match_ended = 7;
inline void GameInfo::clear_is_match_ended() {
  is_match_ended_ = false;
}
inline bool GameInfo::is_match_ended() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameInfo.is_match_ended)
  return is_match_ended_;
}
inline void GameInfo::set_is_match_ended(bool value) {
  
  is_match_ended_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameInfo.is_match_ended)
}

// -------------------------------------------------------------------

// GameTickPacket

// repeated .rlbot.api.PlayerInfo players = 1;
inline int GameTickPacket::players_size() const {
  return players_.size();
}
inline void GameTickPacket::clear_players() {
  players_.Clear();
}
inline const ::rlbot::api::PlayerInfo& GameTickPacket::players(int index) const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.players)
  return players_.Get(index);
}
inline ::rlbot::api::PlayerInfo* GameTickPacket::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.players)
  return players_.Mutable(index);
}
inline ::rlbot::api::PlayerInfo* GameTickPacket::add_players() {
  // @@protoc_insertion_point(field_add:rlbot.api.GameTickPacket.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >*
GameTickPacket::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:rlbot.api.GameTickPacket.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::PlayerInfo >&
GameTickPacket::players() const {
  // @@protoc_insertion_point(field_list:rlbot.api.GameTickPacket.players)
  return players_;
}

// int32 player_index = 2;
inline void GameTickPacket::clear_player_index() {
  player_index_ = 0;
}
inline ::google::protobuf::int32 GameTickPacket::player_index() const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.player_index)
  return player_index_;
}
inline void GameTickPacket::set_player_index(::google::protobuf::int32 value) {
  
  player_index_ = value;
  // @@protoc_insertion_point(field_set:rlbot.api.GameTickPacket.player_index)
}

// repeated .rlbot.api.BoostInfo boost_pads = 3;
inline int GameTickPacket::boost_pads_size() const {
  return boost_pads_.size();
}
inline void GameTickPacket::clear_boost_pads() {
  boost_pads_.Clear();
}
inline const ::rlbot::api::BoostInfo& GameTickPacket::boost_pads(int index) const {
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Get(index);
}
inline ::rlbot::api::BoostInfo* GameTickPacket::mutable_boost_pads(int index) {
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Mutable(index);
}
inline ::rlbot::api::BoostInfo* GameTickPacket::add_boost_pads() {
  // @@protoc_insertion_point(field_add:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >*
GameTickPacket::mutable_boost_pads() {
  // @@protoc_insertion_point(field_mutable_list:rlbot.api.GameTickPacket.boost_pads)
  return &boost_pads_;
}
inline const ::google::protobuf::RepeatedPtrField< ::rlbot::api::BoostInfo >&
GameTickPacket::boost_pads() const {
  // @@protoc_insertion_point(field_list:rlbot.api.GameTickPacket.boost_pads)
  return boost_pads_;
}

// .rlbot.api.BallInfo ball = 4;
inline bool GameTickPacket::has_ball() const {
  return this != internal_default_instance() && ball_ != NULL;
}
inline void GameTickPacket::clear_ball() {
  if (GetArenaNoVirtual() == NULL && ball_ != NULL) {
    delete ball_;
  }
  ball_ = NULL;
}
inline const ::rlbot::api::BallInfo& GameTickPacket::ball() const {
  const ::rlbot::api::BallInfo* p = ball_;
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.ball)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::BallInfo*>(
      &::rlbot::api::_BallInfo_default_instance_);
}
inline ::rlbot::api::BallInfo* GameTickPacket::release_ball() {
  // @@protoc_insertion_point(field_release:rlbot.api.GameTickPacket.ball)
  
  ::rlbot::api::BallInfo* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline ::rlbot::api::BallInfo* GameTickPacket::mutable_ball() {
  
  if (ball_ == NULL) {
    ball_ = new ::rlbot::api::BallInfo;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.ball)
  return ball_;
}
inline void GameTickPacket::set_allocated_ball(::rlbot::api::BallInfo* ball) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ball_;
  }
  if (ball) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ball = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    
  } else {
    
  }
  ball_ = ball;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.GameTickPacket.ball)
}

// .rlbot.api.GameInfo game_info = 5;
inline bool GameTickPacket::has_game_info() const {
  return this != internal_default_instance() && game_info_ != NULL;
}
inline void GameTickPacket::clear_game_info() {
  if (GetArenaNoVirtual() == NULL && game_info_ != NULL) {
    delete game_info_;
  }
  game_info_ = NULL;
}
inline const ::rlbot::api::GameInfo& GameTickPacket::game_info() const {
  const ::rlbot::api::GameInfo* p = game_info_;
  // @@protoc_insertion_point(field_get:rlbot.api.GameTickPacket.game_info)
  return p != NULL ? *p : *reinterpret_cast<const ::rlbot::api::GameInfo*>(
      &::rlbot::api::_GameInfo_default_instance_);
}
inline ::rlbot::api::GameInfo* GameTickPacket::release_game_info() {
  // @@protoc_insertion_point(field_release:rlbot.api.GameTickPacket.game_info)
  
  ::rlbot::api::GameInfo* temp = game_info_;
  game_info_ = NULL;
  return temp;
}
inline ::rlbot::api::GameInfo* GameTickPacket::mutable_game_info() {
  
  if (game_info_ == NULL) {
    game_info_ = new ::rlbot::api::GameInfo;
  }
  // @@protoc_insertion_point(field_mutable:rlbot.api.GameTickPacket.game_info)
  return game_info_;
}
inline void GameTickPacket::set_allocated_game_info(::rlbot::api::GameInfo* game_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete game_info_;
  }
  if (game_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game_info, submessage_arena);
    }
    
  } else {
    
  }
  game_info_ = game_info;
  // @@protoc_insertion_point(field_set_allocated:rlbot.api.GameTickPacket.game_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace rlbot

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_5fdata_2eproto__INCLUDED
